<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>浅克隆</title>
    <script src="./utils/utils.js"></script>
    <script>
      var arr = [11, 22, 33, [44, 55, [66, 77]]]
      var obj = {
        name: 'DEMO',
        age: 18,
        arr: [11, 22, 33, [44, 55]],
        favs: {
          type: 'ball',
          price: 22
        },
        [Symbol(11)]: 'Symbol11',
        reg: /^$/,
        date: new Date(),
        fn: function () {},
        sb: Symbol(),
        [Symbol(22)]: 'Symbol22'
      }
      // (1)数组浅拷贝
      // 浅克隆只克隆第一层:
      // 1.展开运算符
      var newArr = [...arr] // arr[3] === newArr[3] 依然指向同一个内存地址，属于浅克隆
      // 2.Array.prototype.slice
      newArr = arr.slice()
      // 3.concat一个空的数组
      newArr = arr.concat([])

      // (2)对象的浅拷贝
      // 1.展开运算符
      var newObj = { ...obj }
      // 2.Object.assign
      newObj = Object.assign({}, obj)
      // // 3.循环
      var newObj = {}
      myEach(obj, (item, key) => {
        newObj[key] = item
      })
      //第三种循环不能处理Symbol()属性

      // A.封装一个浅克隆的方法
      function shallowClone(obj) {
        var type = getType(obj),
          oConstructor = obj.constructor
        // Symbol/BigInt
        if (/^(symbol|bigint)$/i.test(type)) return Object(obj)
        // 数组/对象
        if (/^(object|array)$/i.test(type)) {
          var keys = [...Object.keys(obj), ...Object.getOwnPropertySymbols(obj)]
          var res = new oConstructor()
          myEach(keys, (key) => {
            res[key] = obj[key]
          })
          return res
          // 直接使用扩展运算符
          // return type === 'array' ? [...obj] : { ...obj }
        }
        return obj
      }
      // B.封装一个深克隆的方法
      function deepClone(target) {
        const type = getType(target)
        //非数组或者对象直接返回传入的内容
        if (!/^(object|array)$/i.test(type)) return target
        if (/array/i.test(type)) {
          let arr = []
          _.myEach(target, (item, index) => {
            if (Array.isArray(item)) {
              arr[index] = deepClone(item)
            } else {
              arr[index] = item
            }
          })
          return arr
        }
        //遍历对象
        if (/object/i.test(type)) {
          let obj = {}
          _.myEach(target, (item, index) => {
            if (/object/i.test(type)) {
              obj[index] = deepClone(item)
            } else {
              obj[index] = item
            }
          })
          return obj
        }
      }

      // var a1 = deepClone(arr)
      // console.log(a1)

      // stringify会识别不了 RegExp, Function, Date, Symbol
      // var obj1 = JSON.parse(JSON.stringify(obj))
      // var obj1 = deepClone(obj)
      // console.log(obj)
      // console.log(obj1)

      /* myEach(obj, (item, index) => {
        console.log(item, index)
      }) */

      // console.log(Object.entries(obj))  不能识别key是Symbol的值
    </script>
  </head>
  <body></body>
</html>
