<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>类型检测</title>
  </head>
  <body>
    <script>
      // 1.typeof  直接在计算机底层基于数据类型的值(二进制)进行检测
      console.log(typeof null) // 'object'
      console.log(typeof NaN) // 'number'
      console.log(typeof undefined) // 'undefined'
      console.log(typeof []) // 'object'
      console.log(typeof /.?/) // 'object'
      console.log(typeof function () {}) // 'function'
      console.log('###############')
      /* 2.instanceof 检测当前实例是否属于这个类
       只要当前类出现在实例的原型链上，结果都是true 
       缺点： 1.我们可以任意修改原型的指向，会导致判断很不准确
             2.不能检测基本类型
       */
      var arr = []
      console.log(arr instanceof Array) // true
      console.log(arr instanceof RegExp) // false
      console.log(arr instanceof Object) // true
      /*  function fn() {
        this.x = 9
      }
      fn.prototype = Object.create(Array.prototype)
      var f = new fn()
      console.log(f instanceof Array) // true 
      console.log(1 instanceof Number) // false
      */

      //手写一个instanceof
      function myInstanceof(example, classObj) {
        let classObjPrototype = classObj.prototype,
          proto = Object.getPrototypeOf(example)
        while (true) {
          if (proto === null) {
            //Object.prototype.__proto__ => null
            return false
          }
          if (classObjPrototype === proto) {
            return true
          }
          //1.获取proto的原型
          proto = Object.getPrototypeOf(proto)
        }
      }
      console.log(myInstanceof(arr, Array))
      console.log(myInstanceof(arr, RegExp))
      console.log(myInstanceof(arr, Object))
      console.log('############')
      // 3.constructor
      // constructor也可以自定义，所以也不准
      var num = 1
      Number.prototype.constructor = { x: 999 }
      console.log(arr.constructor === Array) // true
      console.log(arr.constructor === RegExp) // false
      console.log(arr.constructor === Object) // false
      console.log(num.constructor === Number) // true
      // 4.Object.prototype.toString.call
      console.log(Object.prototype.toString.call('')) //[object String]
      console.log(Object.prototype.toString.call(true)) //[object Boolean]
      console.log(Object.prototype.toString.call(2)) //[object Number]
      console.log(Object.prototype.toString.call({})) //[object Object]
      console.log(Object.prototype.toString.call([])) //[object Array]
      console.log(Object.prototype.toString.call(function(){})) //[object Function]
      console.log(Object.prototype.toString.call(new Date())) //[object Date]
      console.log(Object.prototype.toString.call(/.?/)) //[object RegExp]
      console.log(Object.prototype.toString.call(Symbol(8))) //[object Symbol]
      console.log('##################')
      // 1.写一个检测类型的公共方法
      function toType(target) {
        let res = ''
        const arr = ['String', 'Boolean', 'Number', 'Object', 'Array', 'Function', 'Date', 'RegExp', 'Symbol', 'Undefined', 'Null', 'Arguments', 'HTMLCollection']
        arr.forEach(item => {
          if (Object.prototype.toString.call(target) === `[object ${item}]`) {
           res = item.toLowerCase()
          }
        })
        return res
      }
      // 2.另一种写法
      function toType1(target) {
        let type2obj = {}
        const arr = ['String', 'Boolean', 'Number', 'Object', 'Array', 'Function', 'Date', 'RegExp', 'Symbol', 'Undefined', 'Null']
        arr.forEach(item => {
          type2obj[`[object ${item}]`] = item.toLowerCase()
        })
        return type2obj[Object.prototype.toString.call(target)]
      }

      console.log(toType(9))
    </script>
  </body>
</html>
